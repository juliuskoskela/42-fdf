1. Parse input
	Return vtx_list
2. Transform vectors
	2.1 Front
		X = X
		Y = Y
		Z = Z
	2.1 Top-Down
		X = X
		Y = Z
		Z = Y
	2.2 Orthogonal

	private function translation()
		{
			$this->identity(1);
			$this->_matrix[3] = $this->_vtc->_x;
			$this->_matrix[7] = $this->_vtc->_y;
			$this->_matrix[11] = $this->_vtc->_z;
		}

		private function rotation_x()
		{
			$this->identity(1);
			$this->_matrix[0] = 1;
			$this->_matrix[5] = cos($this->_angle);
			$this->_matrix[6] = -sin($this->_angle);
			$this->_matrix[9] = sin($this->_angle);
			$this->_matrix[10] = cos($this->_angle);
		}

		private function rotation_y()
		{
			$this->identity(1);
			$this->_matrix[0] = cos($this->_angle);
			$this->_matrix[2] = sin($this->_angle);
			$this->_matrix[5] = 1;
			$this->_matrix[8] = -sin($this->_angle);
			$this->_matrix[10] = cos($this->_angle);
		}

		private function rotation_z()
		{
			$this->identity(1);
			$this->_matrix[0] = cos($this->_angle);
			$this->_matrix[1] = -sin($this->_angle);
			$this->_matrix[4] = sin($this->_angle);
			$this->_matrix[5] = cos($this->_angle);
			$this->_matrix[10] = 1;
		}

		private function projection()
		{
			$this->identity(1);
			$this->_matrix[5] = 1 / tan(0.5 * deg2rad($this->_fov));
			$this->_matrix[0] = $this->_matrix[5] / $this->_ratio;
			$this->_matrix[10] = -1 * (-$this->_near - $this->_far) /
				($this->_near - $this->_far);
			$this->_matrix[14] = -1;
			$this->_matrix[11] = (2 * $this->_near * $this->_far) /
				($this->_near - $this->_far);
			$this->_matrix[15] = 0;
		}